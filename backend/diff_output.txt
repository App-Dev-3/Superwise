diff --git a/backend/src/modules/users/users.controller.spec.ts b/backend/src/modules/users/users.controller.spec.ts
index cc0457e..c00f8b9 100644
--- a/backend/src/modules/users/users.controller.spec.ts
+++ b/backend/src/modules/users/users.controller.spec.ts
@@ -31,6 +31,7 @@ describe('UsersController', () => {
     findBlockedSupervisorsByStudentUserId: jest.fn(),
     createUserBlock: jest.fn(),
     deleteUserBlock: jest.fn(),
+    searchUsers: jest.fn(),
   };
 
   const USER_UUID = '123e4567-e89b-12d3-a456-426614174000';
@@ -487,4 +488,19 @@ describe('UsersController', () => {
       ).rejects.toThrow(expectedError);
     });
   });
+
+  describe('searchUsers', () => {
+    it('should search users with the provided query', async () => {
+      // Arrange
+      const searchQuery = 'test';
+      mockUsersService.searchUsers.mockResolvedValue([mockUser]);
+
+      // Act
+      const result = await controller.searchUsers(searchQuery);
+
+      // Assert
+      expect(result).toEqual([mockUser]);
+      expect(mockUsersService.searchUsers).toHaveBeenCalledWith(searchQuery);
+    });
+  });
 });
diff --git a/backend/src/modules/users/users.controller.ts b/backend/src/modules/users/users.controller.ts
index 5f70f8c..ec1148d 100644
--- a/backend/src/modules/users/users.controller.ts
+++ b/backend/src/modules/users/users.controller.ts
@@ -170,65 +170,24 @@ export class UsersController {
   @Get('search')
   @ApiOperation({
     summary: 'Unified search for users',
-    description: 'Search for users by any combination of email, name, or tags.',
+    description: 'Search for users by email, first name, or last name with a single search string.',
   })
   @ApiQuery({
-    name: 'email',
-    required: false,
-    description: 'Email address to search for (exact match)',
-    example: 'studentId@fhstp.ac.at',
-    type: String,
-  })
-  @ApiQuery({
-    name: 'firstName',
-    required: false,
-    description: 'First name to search for (case insensitive, partial match)',
-    example: 'Max',
-    type: String,
-  })
-  @ApiQuery({
-    name: 'lastName',
-    required: false,
-    description: 'Last name to search for (case insensitive, partial match)',
-    example: 'Mustermann',
-    type: String,
-  })
-  @ApiQuery({
-    name: 'tagId',
-    required: false,
-    description: 'Single tag ID to search for (UUID)',
-    example: 'f47ac10b-58cc-4372-a567-0e02b2c3d479',
-    type: String,
-  })
-  @ApiQuery({
-    name: 'tagIds',
-    required: false,
-    description: 'Comma-separated list of tag IDs (UUIDs)',
-    example: 'f47ac10b-58cc-4372-a567-0e02b2c3d479,e47ac10b-58cc-4372-a567-0e02b2c3d480',
+    name: 'query',
+    required: true,
+    description:
+      'Search string to match against email, first name, or last name (case insensitive, partial match)',
+    example: 'john',
     type: String,
   })
   @ApiResponse({
     status: 200,
-    description: 'Returns users matching the search criteria',
+    description: 'Returns users matching the search criteria (limited to 15 results)',
     type: [User],
   })
-  @ApiResponse({ status: 400, description: 'Bad request - Invalid parameters' })
-  searchUsers(
-    @Query('email') email?: string,
-    @Query('firstName') firstName?: string,
-    @Query('lastName') lastName?: string,
-    @Query('tagId') tagId?: string,
-    @Query('tagIds') tagIds?: string,
-  ): Promise<User[]> {
-    const tagIdsArray = tagIds ? tagIds.split(',').map(id => id.trim()) : [];
-
-    return this.usersService.searchUsers({
-      email,
-      firstName,
-      lastName,
-      tagId,
-      tagIds: tagIdsArray,
-    });
+  @ApiResponse({ status: 400, description: 'Bad request - Invalid parameter' })
+  searchUsers(@Query('query') query: string): Promise<User[]> {
+    return this.usersService.searchUsers(query);
   }
 
   @Get('search/by-email')
diff --git a/backend/src/modules/users/users.repository.spec.ts b/backend/src/modules/users/users.repository.spec.ts
index a096a0c..2c03737 100644
--- a/backend/src/modules/users/users.repository.spec.ts
+++ b/backend/src/modules/users/users.repository.spec.ts
@@ -87,102 +87,51 @@ describe('UsersRepository', () => {
     expect(repository).toBeDefined();
   });
   describe('findUsers', () => {
-    it('should return users matching email', async () => {
+    it('should return users matching email query', async () => {
       // Arrange
-      const searchParams = {
-        email: 'exampleStudent1@fhstp.ac.at',
-        firstName: undefined,
-        lastName: undefined,
-        tagId: undefined,
-        tagIds: [],
-      };
+      const searchQuery = 'exampleStudent1@fhstp.ac.at';
       mockPrismaService.user.findMany.mockResolvedValue([mockUser]);
 
       // Act
-      const result = await repository.findUsers(searchParams);
+      const result = await repository.searchUsers(searchQuery);
 
       // Assert
       expect(result).toEqual([mockUser]);
       expect(mockPrismaService.user.findMany).toHaveBeenCalledWith({
         where: {
           is_deleted: false,
-          email: 'exampleStudent1@fhstp.ac.at',
-        },
-        orderBy: [{ last_name: 'asc' }, { first_name: 'asc' }],
-        include: {
-          tags: {
-            include: {
-              tag: true,
+          OR: [
+            {
+              email: {
+                contains: searchQuery,
+                mode: 'insensitive',
+              },
             },
-            orderBy: {
-              priority: 'asc',
+            {
+              first_name: {
+                contains: searchQuery,
+                mode: 'insensitive',
+              },
             },
-          },
-        },
-      });
-    });
-
-    it('should return users matching firstName', async () => {
-      // Arrange
-      const searchParams = {
-        email: undefined,
-        firstName: 'Max',
-        lastName: undefined,
-        tagId: undefined,
-        tagIds: [],
-      };
-      mockPrismaService.user.findMany.mockResolvedValue([mockUser]);
-
-      // Act
-      const result = await repository.findUsers(searchParams);
-
-      // Assert
-      expect(result).toEqual([mockUser]);
-      expect(mockPrismaService.user.findMany).toHaveBeenCalledWith({
-        where: {
-          is_deleted: false,
-          first_name: {
-            contains: 'Max',
-            mode: 'insensitive',
-          },
-        },
-        orderBy: [{ last_name: 'asc' }, { first_name: 'asc' }],
-        include: {
-          tags: {
-            include: {
-              tag: true,
+            {
+              last_name: {
+                contains: searchQuery,
+                mode: 'insensitive',
+              },
             },
-            orderBy: {
-              priority: 'asc',
+            {
+              tags: {
+                some: {
+                  tag: {
+                    tag_name: {
+                      contains: searchQuery,
+                      mode: 'insensitive',
+                    },
+                  },
+                },
+              },
             },
-          },
-        },
-      });
-    });
-
-    it('should return users matching lastName', async () => {
-      // Arrange
-      const searchParams = {
-        email: undefined,
-        firstName: undefined,
-        lastName: 'Mustermann',
-        tagId: undefined,
-        tagIds: [],
-      };
-      mockPrismaService.user.findMany.mockResolvedValue([mockUser]);
-
-      // Act
-      const result = await repository.findUsers(searchParams);
-
-      // Assert
-      expect(result).toEqual([mockUser]);
-      expect(mockPrismaService.user.findMany).toHaveBeenCalledWith({
-        where: {
-          is_deleted: false,
-          last_name: {
-            contains: 'Mustermann',
-            mode: 'insensitive',
-          },
+          ],
         },
         orderBy: [{ last_name: 'asc' }, { first_name: 'asc' }],
         include: {
@@ -195,187 +144,148 @@ describe('UsersRepository', () => {
             },
           },
         },
+        take: 15,
       });
     });
 
-    it('should return users matching single tagId', async () => {
+    it('should return users matching first name query', async () => {
       // Arrange
-      const searchParams = {
-        email: undefined,
-        firstName: undefined,
-        lastName: undefined,
-        tagId: TAG_UUID_1,
-        tagIds: [],
-      };
+      const searchQuery = 'Max';
       mockPrismaService.user.findMany.mockResolvedValue([mockUser]);
 
       // Act
-      const result = await repository.findUsers(searchParams);
+      const result = await repository.searchUsers(searchQuery);
 
       // Assert
       expect(result).toEqual([mockUser]);
-      expect(mockPrismaService.user.findMany).toHaveBeenCalledWith({
-        where: {
-          is_deleted: false,
-          tags: {
-            some: {
-              tag_id: {
-                in: [TAG_UUID_1],
-              },
-            },
-          },
-        },
-        orderBy: [{ last_name: 'asc' }, { first_name: 'asc' }],
-        include: {
-          tags: {
-            include: {
-              tag: true,
-            },
-            orderBy: {
-              priority: 'asc',
-            },
-          },
-        },
-      });
+      expect(mockPrismaService.user.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            is_deleted: false,
+            OR: expect.arrayContaining([
+              expect.objectContaining({
+                first_name: {
+                  contains: searchQuery,
+                  mode: 'insensitive',
+                },
+              }),
+              expect.objectContaining({
+                tags: {
+                  some: {
+                    tag: {
+                      tag_name: {
+                        contains: searchQuery,
+                        mode: 'insensitive',
+                      },
+                    },
+                  },
+                },
+              }),
+            ]),
+          },
+          take: 15,
+        }),
+      );
     });
 
-    it('should return users matching multiple tagIds', async () => {
+    it('should return users matching last name query', async () => {
       // Arrange
-      const searchParams = {
-        email: undefined,
-        firstName: undefined,
-        lastName: undefined,
-        tagId: undefined,
-        tagIds: [TAG_UUID_1, TAG_UUID_2],
-      };
+      const searchQuery = 'Mustermann';
       mockPrismaService.user.findMany.mockResolvedValue([mockUser]);
 
       // Act
-      const result = await repository.findUsers(searchParams);
+      const result = await repository.searchUsers(searchQuery);
 
       // Assert
       expect(result).toEqual([mockUser]);
-      expect(mockPrismaService.user.findMany).toHaveBeenCalledWith({
-        where: {
-          is_deleted: false,
-          tags: {
-            some: {
-              tag_id: {
-                in: [TAG_UUID_1, TAG_UUID_2],
-              },
-            },
-          },
-        },
-        orderBy: [{ last_name: 'asc' }, { first_name: 'asc' }],
-        include: {
-          tags: {
-            include: {
-              tag: true,
-            },
-            orderBy: {
-              priority: 'asc',
-            },
-          },
-        },
-      });
+      expect(mockPrismaService.user.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            is_deleted: false,
+            OR: expect.arrayContaining([
+              expect.objectContaining({
+                last_name: {
+                  contains: searchQuery,
+                  mode: 'insensitive',
+                },
+              }),
+              expect.objectContaining({
+                tags: {
+                  some: {
+                    tag: {
+                      tag_name: {
+                        contains: searchQuery,
+                        mode: 'insensitive',
+                      },
+                    },
+                  },
+                },
+              }),
+            ]),
+          },
+          take: 15,
+        }),
+      );
     });
 
-    it('should return users matching combination of parameters', async () => {
+    it('should return empty array when search query is empty', async () => {
       // Arrange
-      const searchParams = {
-        email: undefined,
-        firstName: 'Max',
-        lastName: 'Mustermann',
-        tagId: TAG_UUID_1,
-        tagIds: [],
-      };
-      mockPrismaService.user.findMany.mockResolvedValue([mockUser]);
+      const searchQuery = '';
 
       // Act
-      const result = await repository.findUsers(searchParams);
+      const result = await repository.searchUsers(searchQuery);
 
       // Assert
-      expect(result).toEqual([mockUser]);
-      expect(mockPrismaService.user.findMany).toHaveBeenCalledWith({
-        where: {
-          is_deleted: false,
-          first_name: {
-            contains: 'Max',
-            mode: 'insensitive',
-          },
-          last_name: {
-            contains: 'Mustermann',
-            mode: 'insensitive',
-          },
-          tags: {
-            some: {
-              tag_id: {
-                in: [TAG_UUID_1],
-              },
-            },
-          },
-        },
-        orderBy: [{ last_name: 'asc' }, { first_name: 'asc' }],
-        include: {
-          tags: {
-            include: {
-              tag: true,
-            },
-            orderBy: {
-              priority: 'asc',
-            },
-          },
-        },
-      });
+      expect(result).toEqual([]);
+      expect(mockPrismaService.user.findMany).not.toHaveBeenCalled();
     });
 
-    it('should return empty array when no parameters provided', async () => {
+    it('should sanitize search query by trimming whitespace', async () => {
       // Arrange
-      const searchParams = {
-        email: undefined,
-        firstName: undefined,
-        lastName: undefined,
-        tagId: undefined,
-        tagIds: [],
-      };
-      mockPrismaService.user.findMany.mockResolvedValue([]);
+      const searchQuery = '  Max  ';
+      const sanitizedQuery = 'Max';
+      mockPrismaService.user.findMany.mockResolvedValue([mockUser]);
 
       // Act
-      const result = await repository.findUsers(searchParams);
-
-      // Assert
-      expect(result).toEqual([]);
-      expect(mockPrismaService.user.findMany).toHaveBeenCalledWith({
-        where: {
-          is_deleted: false,
-        },
-        orderBy: [{ last_name: 'asc' }, { first_name: 'asc' }],
-        include: {
-          tags: {
-            include: {
-              tag: true,
-            },
-            orderBy: {
-              priority: 'asc',
-            },
-          },
-        },
-      });
+      await repository.searchUsers(searchQuery);
+
+      // Assert
+      expect(mockPrismaService.user.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            is_deleted: false,
+            OR: expect.arrayContaining([
+              expect.objectContaining({
+                first_name: {
+                  contains: sanitizedQuery,
+                  mode: 'insensitive',
+                },
+              }),
+              expect.objectContaining({
+                tags: {
+                  some: {
+                    tag: {
+                      tag_name: {
+                        contains: sanitizedQuery,
+                        mode: 'insensitive',
+                      },
+                    },
+                  },
+                },
+              }),
+            ]),
+          },
+        }),
+      );
     });
 
     it('should return empty array when no users match search criteria', async () => {
       // Arrange
-      const searchParams = {
-        email: undefined,
-        firstName: 'NonExistent',
-        lastName: undefined,
-        tagId: undefined,
-        tagIds: [],
-      };
+      const searchQuery = 'NonExistent';
       mockPrismaService.user.findMany.mockResolvedValue([]);
 
       // Act
-      const result = await repository.findUsers(searchParams);
+      const result = await repository.searchUsers(searchQuery);
 
       // Assert
       expect(result).toEqual([]);
diff --git a/backend/src/modules/users/users.repository.ts b/backend/src/modules/users/users.repository.ts
index c52bc8f..68d091d 100644
--- a/backend/src/modules/users/users.repository.ts
+++ b/backend/src/modules/users/users.repository.ts
@@ -22,6 +22,7 @@ export interface IUsersRepository {
   findUsersByLastName(lastName: string): Promise<User[]>;
   findUsersByTagId(tagId: string): Promise<User[]>;
   findUsersByTagIds(tagIds: string[]): Promise<User[]>;
+  searchUsers(searchQuery: string): Promise<User[]>;
   updateUser(
     id: string,
     updateData: {
@@ -51,14 +52,6 @@ export interface IUsersRepository {
   findUserBlockByIds(blockerUserId: string, blockedUserId: string): Promise<UserBlock | null>;
 }
 
-interface SearchParams {
-  email?: string;
-  firstName?: string;
-  lastName?: string;
-  tagId?: string;
-  tagIds: string[];
-}
-
 @Injectable()
 export class UsersRepository implements IUsersRepository {
   constructor(private readonly prisma: PrismaService) {}
@@ -77,44 +70,53 @@ export class UsersRepository implements IUsersRepository {
     });
   }
 
-  async searchUsers(searchParams: SearchParams): Promise<User[]> {
-    const { email, firstName, lastName, tagId, tagIds } = searchParams;
-    const whereConditions: Prisma.UserWhereInput = {
-      is_deleted: false,
-    };
-
-    if (email) {
-      whereConditions.email = email;
+  async searchUsers(searchQuery: string): Promise<User[]> {
+    // If search query is empty, return empty array
+    if (!searchQuery || searchQuery.trim() === '') {
+      return [];
     }
 
-    if (firstName) {
-      whereConditions.first_name = {
-        contains: firstName,
-        mode: 'insensitive',
-      };
-    }
-
-    if (lastName) {
-      whereConditions.last_name = {
-        contains: lastName,
-        mode: 'insensitive',
-      };
-    }
+    // Sanitize the search query - trim whitespace and ensure it's safe
+    const sanitizedQuery = searchQuery.trim();
 
-    if (tagId || (tagIds && tagIds.length > 0)) {
-      const allTagIds = [...(tagId ? [tagId] : []), ...tagIds];
-
-      if (allTagIds.length > 0) {
-        whereConditions.tags = {
-          some: {
-            tag_id: {
-              in: allTagIds,
+    // Build the where conditions to search across multiple fields
+    const whereConditions: Prisma.UserWhereInput = {
+      is_deleted: false,
+      OR: [
+        {
+          email: {
+            contains: sanitizedQuery,
+            mode: 'insensitive',
+          },
+        },
+        {
+          first_name: {
+            contains: sanitizedQuery,
+            mode: 'insensitive',
+          },
+        },
+        {
+          last_name: {
+            contains: sanitizedQuery,
+            mode: 'insensitive',
+          },
+        },
+        {
+          tags: {
+            some: {
+              tag: {
+                tag_name: {
+                  contains: sanitizedQuery,
+                  mode: 'insensitive',
+                },
+              },
             },
           },
-        };
-      }
-    }
+        },
+      ],
+    };
 
+    // Return a maximum of 15 users
     return this.prisma.user.findMany({
       where: whereConditions,
       orderBy: [{ last_name: 'asc' }, { first_name: 'asc' }],
@@ -128,6 +130,7 @@ export class UsersRepository implements IUsersRepository {
           },
         },
       },
+      take: 15, // Limit to 15 results
     });
   }
 
diff --git a/backend/src/modules/users/users.service.spec.ts b/backend/src/modules/users/users.service.spec.ts
index b32b6a2..8bbebdc 100644
--- a/backend/src/modules/users/users.service.spec.ts
+++ b/backend/src/modules/users/users.service.spec.ts
@@ -33,6 +33,7 @@ describe('UsersService', () => {
     createUserBlock: jest.fn(),
     deleteUserBlock: jest.fn(),
     findUserBlockByIds: jest.fn(),
+    searchUsers: jest.fn(),
   };
 
   const mockLoggerService = {
@@ -725,4 +726,45 @@ describe('UsersService', () => {
       expect(mockUsersRepository.deleteUserBlock).not.toHaveBeenCalled();
     });
   });
+
+  // Add this test suite for the updated searchUsers method
+  describe('searchUsers', () => {
+    it('should return users matching the search query', async () => {
+      // Arrange
+      const searchQuery = 'test';
+      const expectedUsers = [mockUser];
+      mockUsersRepository.searchUsers.mockResolvedValue(expectedUsers);
+
+      // Act
+      const result = await service.searchUsers(searchQuery);
+
+      // Assert
+      expect(result).toEqual(expectedUsers);
+      expect(mockUsersRepository.searchUsers).toHaveBeenCalledWith(searchQuery);
+    });
+
+    it('should return an empty array when given an empty search query', async () => {
+      // Arrange
+      const searchQuery = '';
+
+      // Act
+      const result = await service.searchUsers(searchQuery);
+
+      // Assert
+      expect(result).toEqual([]);
+      expect(mockUsersRepository.searchUsers).not.toHaveBeenCalled();
+    });
+
+    it('should return an empty array when given a whitespace-only search query', async () => {
+      // Arrange
+      const searchQuery = '   ';
+
+      // Act
+      const result = await service.searchUsers(searchQuery);
+
+      // Assert
+      expect(result).toEqual([]);
+      expect(mockUsersRepository.searchUsers).not.toHaveBeenCalled();
+    });
+  });
 });
diff --git a/backend/src/modules/users/users.service.ts b/backend/src/modules/users/users.service.ts
index c299a0f..6ee6440 100644
--- a/backend/src/modules/users/users.service.ts
+++ b/backend/src/modules/users/users.service.ts
@@ -9,13 +9,6 @@ import { TagsService } from '../tags/tags.service';
 import { UserRegistrationException } from '../../common/exceptions/custom-exceptions/user-registration.exception';
 import { WinstonLoggerService } from '../../common/logging/winston-logger.service';
 
-interface SearchParams {
-  email?: string;
-  firstName?: string;
-  lastName?: string;
-  tagId?: string;
-  tagIds: string[];
-}
 @Injectable()
 export class UsersService {
   constructor(
@@ -152,32 +145,14 @@ export class UsersService {
     return user;
   }
 
-  async searchUsers(searchParams: SearchParams): Promise<User[]> {
-    const { email, firstName, lastName, tagId, tagIds } = searchParams;
-
-    if (!email && !firstName && !lastName && !tagId && tagIds.length === 0) {
+  async searchUsers(searchQuery: string): Promise<User[]> {
+    // Validate search query - if empty, return empty array
+    if (!searchQuery || searchQuery.trim() === '') {
       return [];
     }
 
-    if (email && !firstName && !lastName && !tagId && tagIds.length === 0) {
-      try {
-        const user = await this.findUserByEmail(email);
-        return [user];
-      } catch (error) {
-        if (error instanceof NotFoundException) {
-          return [];
-        }
-        throw error;
-      }
-    }
-
-    return this.usersRepository.searchUsers({
-      email,
-      firstName,
-      lastName,
-      tagId,
-      tagIds,
-    });
+    // Delegate to repository - repository handles sanitization and result limiting
+    return this.usersRepository.searchUsers(searchQuery);
   }
 
   async findUserByEmail(email: string): Promise<User> {
